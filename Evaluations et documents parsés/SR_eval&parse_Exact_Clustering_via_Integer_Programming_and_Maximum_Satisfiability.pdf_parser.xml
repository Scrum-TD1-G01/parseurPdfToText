b'<opml version="1.0">
<article>

->perfect
<preamble>Exact_Clustering_via_Integer_Programming_and_Maximum_Satisfiability.pdf</preamble>
->perfect 

->Perfect 
<title>b\'Exact Clustering via Integer Programming and Maximum Satisfiability\'</title>
->Perfect

->Perfect
<auteur>Exact Clustering via Integer Programming and Maximum Satis&#64257;ability Atsushi Miyauchi,1 Tomohiro Sonobe,2, 3 Noriyoshi Sukegawa4 1 RIKEN AIP, Tokyo, Japan </auteur>
->Perfect

->Perfect
<abstract>Abstract We consider the following general graph clustering problem: given a complete undirected graph G = (V, E, c) with an edge weight function c : E &#8594; Q, we are asked to &#64257;nd a partition C of V that maximizes the sum of edge weights within the clusters in C. Owing to its high generality, this problem has a wide variety of real-world applications, includ- ing correlation clustering, group technology, and community detection. In this study, we investigate the design of mathe- matical programming formulations and constraint satisfaction formulations for the problem. First, we present a novel inte- ger linear programming (ILP) formulation that has far fewer constraints than the standard ILP formulation by Gro&#776;tschel and Wakabayashi (1989). Second, we propose an ILP-based exact algorithm that solves an ILP problem obtained by mod- ifying our above ILP formulation and then performs simple post-processing to produce an optimal solution to the original problem. Third, we present maximum satis&#64257;ability (MaxSAT) counterparts of both our ILP formulation and ILP-based exact algorithm. Computational experiments using well-known real- world datasets demonstrate that our ILP-based approaches and their MaxSAT counterparts are highly effective in terms of both memory ef&#64257;ciency and computation time. </abstract>
->Perfect

->Perfect
<introduction>1 Introduction Clustering is a fundamental tool in data analysis. Roughly speaking, the task of clustering is to divide a given set of objects into subsets of homogeneous objects. To date, vari- ous problem settings and optimization algorithms have been extensively studied (Aggarwal and Reddy 2013; Jain, Murty, and Flynn 1999; Xu and Wunsch 2005). Let us consider the following general graph clustering problem. An instance is a complete undirected graph G = (V, E, c) with an edge weight function c : E &#8594; Q, where Q is the set of rational numbers. For simplicity, we denote cij = c({i, j}) for each {i, j} &#8712; E. The edge weight cij expresses the degree of preference that i, j &#8712; V are assigned to the same cluster; if cij is positive, we wish to assign i, j &#8712; V to the same cluster, whereas if cij is negative, we wish to assign i, j &#8712; V to different clusters. The goal is to &#64257;nd a partition C = {V1, V2, . . . , Vk} (i.e., Copyright c \x03 2018, Association for the Advancement of Arti&#64257;cial Intelligence (www.aaai.org). All rights reserved. \x02k l=1 Vl = V and Vi &#8745; Vj = &#8709; for i \x06= j) of V that maxi- mizes the sum of edge weights within the clusters in C, i.e., \x03 {i,j}&#8712;E cij&#948;(C(i), C(j)), where C(i) is the (unique) cluster to which i &#8712; V belongs and &#948; is Kronecker&#8217;s symbol, which is equal to 1 if two arguments are the same and 0 otherwise. Note here that in this problem, there is no restriction on the number of clusters in the output partition; thus, the algorithms are allowed to specify the optimal number of clusters endoge- nously. This problem is known as the clique partitioning prob- lem (CPP), which was originally introduced by Gro&#776;tschel and Wakabayashi (1989). As described in Section 2, the high gen- erality of CPP leads to a wide variety of real-world applica- tions, including correlation clustering, group technology, and community detection. The NP-hardness was demonstrated in Wakabayashi (1986). In the &#64257;eld of arti&#64257;cial intelligence, mathematical pro- gramming and constraint satisfaction are known to be key frameworks to solve NP-hard optimization problems. In these frameworks, we &#64257;rst formulate a problem at hand as a math- ematical programming problem or a constraint satisfaction problem such as an integer programming (IP) problem or a maximum satis&#64257;ability (MaxSAT) problem, and then solve it using powerful mathematical programming or constraint satisfaction solvers. For example, in the case of IP problems, we may use Gurobi Optimizer or IBM ILOG CPLEX. The problem we address, CPP, is not an exception; in fact, both of mathematical programming formulations and constraint satisfaction formulations have been actively developed. Mathematical programming formulations. Gro&#776;tschel and Wakabayashi (1989) introduced a 0-1 integer linear programming (ILP) formulation for CPP, which has been employed by many algorithms for CPP and its variants (e.g., (Agarwal and Kempe 2008; Bruckner et al. 2013; Jaehn and Pesch 2013; Miyauchi and Miyamoto 2013; Nowozin and Jegelka 2009; Oosten, Rutten, and Spieksma 2001; Van Gael and Zhu 2007)). The ILP formulation is simple and intuitive, but not suf&#64257;ciently scalable for real- world applications in terms of both memory requirements and computation time. In particular, the issue of memory requirements is quite serious. Letting n = |V |, the ILP for- mulation has 3 \x04n 3 \x05 = &#920;(n3 ) constrains, which grows rapidly as n increases. For example, if n = 1,000, the number of con- The Thirty-Second AAAI Conference on Artificial Intelligence (AAAI-18) 1387 straints reaches the order of half a billion; it is quite dif&#64257;cult to store such an ILP formulation on a standard computer. To overcome this issue, much effort has been dedicated to constructing ILP formulations for CPP with fewer con- straints. Dinh and Thai (2015) addressed a special case of CPP, which is called the modularity maximization prob- lem (Fortunato 2010; Newman and Girvan 2004), and de- rived a set of redundant constraints in the ILP formulation by Gro&#776;tschel and Wakabayashi (1989). By removing the con- straints in advance, they introduced an ILP formulation with fewer constraints for the special case. Recently, Miyauchi and Sukegawa (2015b) generalized Dinh and Thai&#8217;s result to CPP. If m&#8805;0 denotes the number of nonnegative-weighted edges in G, i.e., m&#8805;0 = |{{i, j} &#8712; E : cij &#8805; 0}|, the ILP formulation by Miyauchi and Sukegawa (2015b) has O(nm&#8805;0) constraints, which improves on the ILP formula- tion by Gro&#776;tschel and Wakabayashi (1989) for the case in which m&#8805;0 is not large (e.g., m&#8805;0 = O(n)). However, for most real-world instances of CPP, the pa- rameter m&#8805;0 is large owing to the large number of edges with weight zero; thus, the bene&#64257;t of the above reformulation is quite limited for real-world applications. In fact, com- putational experiments in Miyauchi and Sukegawa (2015b) demonstrated that the decrease in the number of constraints&#8212; which is about 20% at most&#8212;is not signi&#64257;cant. Moreover, their reformulation does not reduce computation time signi&#64257;- cantly; in fact, in some cases computation time increases. Constraint satisfaction formulations. Very recently, Berg and Ja&#776;rvisalo (2017) developed MaxSAT formulations for an optimization problem called the weighted correlation clustering problem (WCC). It should be noted that WCC is equivalent to CPP from an exact optimization perspective (see Example 1 in Section 2). Thus, the MaxSAT formula- tions by Berg and Ja&#776;rvisalo (2017) for WCC can be seen as exact formulations for CPP. WCC and its variants have been actively studied in the &#64257;eld of arti&#64257;cial intelligence (Ahn et al. 2015; Awasthi, Balcan, and Voevodski 2014; Bansal, Blum, and Chawla 2004; Bonchi, Gionis, and Ukkonen 2013; Chierichetti, Dalvi, and Kumar 2014; Kim et al. 2014; Puleo and Milenkovic 2016; Van Gael and Zhu 2007). Speci&#64257;cally, Berg and Ja&#776;rvisalo (2017) developed three MaxSAT formulations: MaxSAT-Transitive, MaxSAT-Unary, and MaxSAT-Binary. MaxSAT-Transitive is the MaxSAT coun- terpart of the ILP formulation by Gro&#776;tschel and Wak- abayashi (1989). MaxSAT-Unary and MaxSAT-Binary are MaxSAT formulations that employ the unary encoding and bi- nary encoding techniques, respectively. In their experiments, the MaxSAT formulations were compared with the ILP for- mulation by Gro&#776;tschel and Wakabayashi (1989). The results of their experiments showed that MaxSAT-Binary outperforms both the other MaxSAT formulations and the ILP formulation. Thus, MaxSAT-Binary is known to be state-of-the-art in terms of exact formulation for WCC and thus for CPP. 1.1 Our Contribution In this study, we further investigate the design of mathemat- ical programming formulations and constraint satisfaction formulations for CPP. Our contribution can be summarized as follows: 1. We present a novel ILP formulation for CPP in which the number of constraints is O(nm&gt;0), where m&gt;0 is the number of positive-weighted edges in G, i.e., m&gt;0 = |{{i, j} &#8712; E : cij &gt; 0}|. </introduction>
-> Incorrect 

-> Incorrect 
<corps>2 National Institute of Informatics, Tokyo, Japan 3 JST, ERATO, Kawarabayashi Large Graph Project, Tokyo, Japan 4 Chuo University, Tokyo, Japan atsushi.miyauchi.hv@riken.jp, tomohiro sonobe@nii.ac.jp, sukegawa.15k@g.chuo-u.ac.jp 2. We also propose an ILP-based exact algorithm for CPP. The algorithm &#64257;rst solves an ILP problem obtained by modifying our above ILP formulation and then performs simple post-processing to obtain an optimal solution to CPP. 3. We present MaxSAT counterparts of both our ILP formu- lation and ILP-based exact algorithm. 4. We conduct thorough experiments to evaluate the effec- tiveness of our ILP-based approaches and their MaxSAT counterparts in terms of both memory ef&#64257;ciency and com- putation time. We &#64257;rst describe our &#64257;rst result above in detail. To design our ILP formulation, we effectively use the above result by Miyauchi and Sukegawa (2015b). Recall that they proposed an ILP formulation for CPP that has O(nm&#8805;0) constraints. The serious problem with their formulation is that for most real-world instances of CPP, the parameter m&#8805;0 is large owing to the large number of edges with weight zero. The critical idea behind the design of our ILP formulation is to perturb the edge weight function of a given instance so that all edges with weight zero have some negative weight. By doing this, the resulting instance has small m&#8805;0; thus, the ILP formulation by Miyauchi and Sukegawa (2015b) for the resulting instance, which is our proposed ILP formulation for the original instance, has far fewer constraints. Our theoreti- cal analysis demonstrates that if the negative values used for the perturbation are close to zero, the proposed formulation obtains an optimal solution to the original instance. We describe our second result in detail. In our ILP for- mulation above, it is necessary to deal with some negative perturbation values very close to zero. Unfortunately, such values may cause numerical instability and therefore increase computation time in practice; hence, such perturbation should be avoided if possible. To this end, we introduce an ILP prob- lem that is identical to our above ILP formulation for CPP except that it uses an unperturbed objective function. This modi&#64257;ed ILP problem also has O(nm&gt;0) constraints but does not depend on the perturbation. However, the ILP prob- lem itself is incomplete as an ILP formulation for CPP; in fact, an optimal solution to the ILP problem may be infeasi- ble for CPP. Thus, to obtain an optimal solution to CPP, the algorithm also performs simple post-processing that runs in linear time. We next describe our third result in detail. As mentioned above, Berg and Ja&#776;rvisalo (2017) introduced a MaxSAT for- mulation called MaxSAT-Transitive, which is the MaxSAT counterpart of the ILP formulation by Gro&#776;tschel and Wak- abayashi (1989). That is, MaxSAT-Transitive uses hard clauses to represent the constraints in the ILP formulation and soft clauses associated with appropriate weights to represent its objective function. Beginning with MaxSAT-Transitive, we 1388 can reproduce our results for ILP in the context of MaxSAT; speci&#64257;cally, we can obtain MaxSAT counterparts of both our ILP formulation and ILP-based exact algorithm. Finally, we describe our fourth result in detail. In a series of experimental assessments, we compare our ILP-based ap- proaches and their MaxSAT counterparts with the previous formulations using well-known real-world datasets arising in the context of correlation clustering, group technology, and community detection. The results demonstrate that our approaches signi&#64257;cantly outperform the state-of-the-art for- mulations in terms of both memory ef&#64257;ciency and computa- tion time. In particular, our ILP-based approaches can solve a real-world instance with a few thousand vertices for which the ILP formulation by Gro&#776;tschel and Wakabayashi (1989) has more than eight billion constraints. 2 Application Examples CPP is a general clustering problem and therefore has a wide variety of applications. Here we provide some important application examples. Example 1 (Correlation clustering). Correlation clustering was introduced by Bansal, Blum, and Chawla (2004) for clustering with qualitative information. As an example, we consider document clustering, in which a set of documents is to be clustered into topics, with the hindering constraint that there is no exact prior de&#64257;nition of what a &#8220;topic&#8221; constitutes. Alternatively, it can be assumed that there exists qualitative similarity information indicating that a number of pairs of documents are similar or dissimilar. In such a situation, the goal of correlation clustering is to &#64257;nd a partition of the set of documents that agrees as much as possible with the similarity information. A mathematical formulation of correlation clustering is as follows: Let G\x04 = (V \x04 , E+, E&#8722;) be an edge-labeled undi- rected graph in which each edge e &#8712; E+ is labeled as &#8220;+&#8221; (similar) and each edge e &#8712; E&#8722; is labeled as &#8220;&#8722;&#8221; (dissim- ilar). Note that E+ &#8745; E&#8722; = &#8709; holds. The maximization version, MAXAGREE, asks for a partition C of V \x04 that max- imizes agreements (the number of + edges within clusters plus the number of &#8722; edges across clusters). The minimiza- tion version, MINDISAGREE, asks for a partition C of V \x04 that minimizes disagreements (the number of &#8722; edges within clusters plus the number of + edges across clusters). These problems are equivalent in terms of optimality and are both NP-hard (Bansal, Blum, and Chawla 2004). WCC, which was mentioned above, deals with edge-weighted generalizations of both MAXAGREE and MINDISAGREE. MAXAGREE and MINDISAGREE can be reduced to CPP. An instance G = (V, E, c) of CPP is constructed as fol- lows: Let V = V \x04 . For each {i, j} &#8712; E, we set cij = 1 if {i, j} &#8712; E+, cij = &#8722;1 if {i, j} &#8712; E&#8722;, and cij = 0 other- wise. Clearly, an optimal solution to CPP corresponds to an optimal solution to both MAXAGREE and MINDISAGREE. It should be noted that WCC can also be reduced to CPP and CPP can be reduced to WCC. Example 2 (Group technology). Group technology plays a key role in the design of ef&#64257;cient manufacturing sys- tems (Groover 2007). Suppose that the goal is to develop a manufacturing system for some new product, comprising p parts that are processed by q machines. In such a situation, the goal of group technology is to &#64257;nd a suitable partition of the set of parts and machines needed to de&#64257;ne an ef&#64257;cient cellular manufacturing system. As mentioned in Oosten, Rutten, and Spieksma (2001), group technology can be modeled as CPP. An instance G = (V, E, c) of CPP is constructed as follows: Let V be a union of the set of p parts and the set of q machines. An edge {i, j} &#8712; E between a part i and a machine j has weight 1 if i is processed by j and &#8722;1 otherwise. Each edge between two parts or two machines has weight zero. Example 3 (Community detection). Community detection is a fundamental task in network analysis that aims to &#64257;nd a partition of the set of vertices into communities (Fortu- nato 2010). Intuitively speaking, a community is a subset of vertices densely connected internally but sparsely con- nected with the rest of the network. Recently, the issue of community detection in bipartite networks has garnered a signi&#64257;cant amount interest (Fortunato 2010). Barber (2007) introduced a quality function called the bipartite modular- ity, which is appropriate for community detection in bipar- tite networks. Let G\x04 = (V \x04 , E\x04 ) be an undirected bipar- tite graph for which it is known that V \x04 is divided into V \x04 L and V \x04 R so that each edge has one endpoint in V \x04 L and the other in V \x04 R. The bipartite modularity, a quality func- tion for a partition C of V \x04 , can be written as Qb(C) = 1 |E\x02| \x03 i&#8712;V \x02 L \x03 j&#8712;V \x02 R \x06 Aij &#8722; didj |E\x02| \x07 &#948;(C(i), C(j)), where Aij is the (i, j) component of the adjacency matrix of G\x04 and di is the degree of i &#8712; V \x04 . The bipartite modularity maximization problem is NP-hard (Miyauchi and Sukegawa 2015a). The problem can be reduced to CPP. An instance G = (V, E, c) of CPP is constructed as follows: Let V = V \x04 . An edge {i, j} &#8712; E between i &#8712; V \x04 L and j &#8712; V \x04 R has weight Aij |E\x02| &#8722; didj |E\x02|2 . Each edge between two vertices in V \x04 L or two vertices in V \x04 R has weight zero. 3 ILP Formulation We &#64257;rst revisit the standard formulation by Gro&#776;tschel and Wakabayashi (1989) and the reformulation by Miyauchi and Sukegawa (2015b). Let V = {1, 2, . . . , n} and P = {(i, j) : 1 &#8804; i &lt; j &#8804; n}. For each (i, j) &#8712; P, we introduce a decision variable xij equal to 1 if i, j &#8712; V are in the same cluster and 0 otherwise. Then the ILP formulation by Gro&#776;tschel and Wakabayashi (1989) can be represented as follows: P(G) : max. \x08 (i,j)&#8712;P cijxij s. t. xij + xjk &#8722; xik &#8804; 1 &#8704;(i, j, k) &#8712; T, xij &#8722; xjk + xik &#8804; 1 &#8704;(i, j, k) &#8712; T, &#8722;xij + xjk + xik &#8804; 1 &#8704;(i, j, k) &#8712; T, xij &#8712; {0, 1} &#8704;(i, j) &#8712; P, where T = {(i, j, k) : 1 &#8804; i &lt; j &lt; k &#8804; n}. The triangle inequality constraints stipulate that for any i, j, k &#8712; V , if 1389 i, j &#8712; V are in the same cluster and j, k &#8712; V are also in the same cluster, then i, k &#8712; V must be in the same cluster. The ILP formulation has \x04n 2 \x05 = &#920;(n2 ) variables and 3 \x04n 3 \x05 = &#920;(n3 ) triangle inequality constraints. Miyauchi and Sukegawa (2015b) derived a set of redun- dant triangle inequality constraints in P(G). By removing the constraints in advance, they introduced the following ILP formulation: RP(G) : max. \x08 (i,j)&#8712;P cijxij s. t. xij + xjk &#8722; xik &#8804; 1 &#8704;(i, j, k) &#8712; T1 &#8805;0, xij &#8722; xjk + xik &#8804; 1 &#8704;(i, j, k) &#8712; T2 &#8805;0, &#8722;xij + xjk + xik &#8804; 1 &#8704;(i, j, k) &#8712; T3 &#8805;0, xij &#8712; {0, 1} &#8704;(i, j) &#8712; P, where T1 &#8805;0 = {(i, j, k) &#8712; T : cij &#8805; 0 or cjk &#8805; 0}, T2 &#8805;0 = {(i, j, k) &#8712; T : cij &#8805; 0 or cik &#8805; 0}, and T3 &#8805;0 = {(i, j, k) &#8712; T : cjk &#8805; 0 or cik &#8805; 0}. They proved the following theorem: Theorem 1 (Theorem 1 in Miyauchi and Sukegawa (2015b)). Let G = (V, E, c) be an arbitrary instance of CPP. P(G) and RP(G) share the same set of optimal solutions. Therefore, we can solve RP(G) instead of P(G) to ob- tain an optimal solution to CPP. Note that the number of triangle inequality constraints in RP(G) can be evaluated as O(nm&#8805;0), where m&#8805;0 is the number of nonnegative- weighted edges in G, i.e., m&#8805;0 = |{(i, j) &#8712; P : cij &#8805; 0}|. 3.1 Our Formulation Here we present our ILP formulation. Without loss of gen- erality, we assume that the edge weight function c is integer- valued. When c is rational-valued, we can immediately obtain an equivalent instance in which c is integer-valued by multi- plying an appropriate value for each cij. Let E0 = {{i, j} &#8712; E : cij = 0}. We de&#64257;ne an edge weight function c so that for each {i, j} &#8712; E, cij = &#8722;\x03 if {i, j} &#8712; E0, cij otherwise, where \x03 &#8712; (0, 1/ \x04n 2 \x05 ). Let us introduce a new instance G = (V, E, c). Then the number of triangle inequality constraints in RP(G) is O(nm&gt;0), where m&gt;0 is the number of positive- weighted edges in G, i.e., m&gt;0 = |{(i, j) &#8712; P : cij &gt; 0}|. It is expected that as \x03 &gt; 0 is suf&#64257;ciently small, an optimal solution to RP(G) is also optimal to RP(G) and thus to P(G). In fact, we have the following theorem: Theorem 2. Let G = (V, E, c) be an arbitrary instance of CPP such that c is integer-valued. Any optimal solution to RP(G) is also optimal to P(G). Proof. Let x = (xij)(i,j)&#8712;P be an arbitrary optimal solution to RP(G). From Theorem 1, x is an optimal solution to P(G), which implies that x satis&#64257;es all the triangle inequality constraints for T. Thus, x is also feasible for P(G). We now show the optimality of x to P(G). Let x = (xij)(i,j)&#8712;P be an optimal solution to P(G) and a its objective value in P(G). Since all the constraints in RP(G) are also con- tained in P(G), the solution x is feasible for RP(G). The ob- jective value of x in RP(G), i.e., \x03 (i,j)&#8712;P cijxij, is strictly greater than a &#8722; 1 because the decrement, due to the change from P(G) to RP(G), of the objective value of x is at most \x03&#183;|E0| &lt; \x04 1/ \x04n 2 \x05\x05 &#183; \x04n 2 \x05 = 1. As for the objective value of x in P(G), i.e., \x03 (i,j)&#8712;P cijxij, we have a &#8805; \x03 (i,j)&#8712;P cijxij &#8805; \x03 (i,j)&#8712;P cijxij &#8805; \x03 (i,j)&#8712;P cijxij &gt; a &#8722; 1, where the &#64257;rst inequality follows from the feasibility of x in P(G), and the third inequality follows from the optimality and feasibility of x and x, respectively, in RP(G). Since the objective value of x in P(G) is an integer, we have \x03 (i,j)&#8712;P cijxij = a. Therefore, x is optimal to P(G). 4 ILP-Based Exact Algorithm We introduce the following ILP problem: RP&#8727; (G) : max. \x08 (i,j)&#8712;P cijxij s. t. xij + xjk &#8722; xik &#8804; 1 &#8704;(i, j, k) &#8712; T1 &gt;0, xij &#8722; xjk + xik &#8804; 1 &#8704;(i, j, k) &#8712; T2 &gt;0, &#8722;xij + xjk + xik &#8804; 1 &#8704;(i, j, k) &#8712; T3 &gt;0, xij &#8712; {0, 1} &#8704;(i, j) &#8712; P, where T1 &gt;0 = {(i, j, k) &#8712; T : cij &gt; 0 or cjk &gt; 0}, T2 &gt;0 = {(i, j, k) &#8712; T : cij &gt; 0 or cik &gt; 0}, and T3 &gt;0 = {(i, j, k) &#8712; T : cjk &gt; 0 or cik &gt; 0}. Note here that the set of constraints is the same as in RP(G), whereas the objective function is the same as in P(G) and RP(G), i.e., the unperturbed one. Unfortunately, RP&#8727; (G) may fail to obtain an optimal solution to P(G). In fact, there exist instances such that an optimal solution to RP&#8727; (G) is infeasible for P(G). For example, consider G = (V, E, c) with V = {1, 2, 3, 4}, c12 = 1, c13 = c23 = &#8722;1, and c14 = c24 = c34 = 0. A 0-1 vector x&#8727; = (x&#8727; ij) such that x&#8727; 12 = x&#8727; 14 = x&#8727; 24 = x&#8727; 34 = 1 and x&#8727; 13 = x&#8727; 23 = 0 is one of the optimal solu- tions to RP&#8727; (G); however, the triangle inequality constraint &#8722;x13 + x34 + x14 &#8804; 1 in P(G) is violated. To obtain an optimal solution to P(G), we perform the following simple post-processing, which we refer to as pp, for an optimal solution x&#8727; to RP&#8727; (G): Let P&#8727; &gt;0 = {(i, j) &#8712; P : x&#8727; ij = 1, cij &gt; 0}. Obtain a set of weakly connected components {V1, V2, . . . , Vk} of (V, P&#8727; &gt;0) by the depth-&#64257;rst search. Output a 0-1 vector x&#8727; that corresponds to the parti- tion {V1, V2, . . . , Vk}, i.e., x&#8727; such that x&#8727; ij = 1 if and only if i, j &#8712; Vq for some q &#8712; {1, 2, . . . , k}. Note that pp runs in time linear in the size of G. 4.1 Correctness Here we demonstrate that our algorithm (i.e., RP&#8727; (G)+pp) returns an optimal solution to P(G). To this end, it suf&#64257;ces 1390 to show that the objective value of x&#8727; remains the same as that of x&#8727; (in P(G) and RP&#8727; (G)) because x&#8727; is feasible for P(G) and x&#8727; is optimal to a relaxation RP&#8727; (G) of P(G). For convenience, we de&#64257;ne P&#8727; in = {(i, j) &#8712; P : x&#8727; ij = 1} and P&#8727; out = P \\ P&#8727; in. We have the following lemmas: Lemma 1. It holds that \x08 (i,j)&#8712;P &#8727; in cijx&#8727; ij = \x08 (i,j)&#8712;P &#8727; in cijx&#8727; ij. Proof. It suf&#64257;ces to show that for any q &#8712; {1, 2, . . . , k}, it holds that x&#8727; ij = 1 for each i, j &#8712; Vq with i &lt; j. Fix q &#8712; {1, 2, . . . , k}. Let i, j be a pair of distinct vertices of Vq. Since Vq is weakly connected by P&#8727; &gt;0, there exists a path on P&#8727; &gt;0 that connects i and j if we ignore the direction of edges. Denote this (undirected) path by i = v0, v1, . . . , vt = j. Since cv0v1 &gt; 0 (and cv1v2 &gt; 0), RP&#8727; (G) has the constraint xv0v1 + xv1v2 &#8722; xv0v2 &#8804; 1. Note here that in this notation, it is necessary that v0 &lt; v1 &lt; v2 holds. If it is not the case, we should swap the order of the indices appropriately. Substituting x&#8727; v0v1 = x&#8727; v1v2 = 1 to this constraint, we have x&#8727; v0v2 = 1. Moreover, since cv2v3 &gt; 0, RP&#8727; (G) also has the constraint xv0v2 + xv2v3 &#8722; xv0v3 &#8804; 1. Substituting x&#8727; v0v2 = x&#8727; v2v3 = 1 to this constraint, we have x&#8727; v0v3 = 1. Repeating this operation, we &#64257;nally have x&#8727; v0vt = x&#8727; ij = 1. Lemma 2. It holds that \x08 (i,j)&#8712;P &#8727; out cijx&#8727; ij &#8804; 0. Proof. For each (i, j) &#8712; P&#8727; out, we have (i, j) / &#8712; P&#8727; &gt;0. If other- wise, then x&#8727; ij = 1 and thus (i, j) &#8712; P&#8727; in. Therefore, for each (i, j) &#8712; P&#8727; out, we have x&#8727; ij = 0 or cij &#8804; 0, which proves the lemma. By Lemmas 1 and 2, we have \x03 (i,j)&#8712;P cijx&#8727; ij = \x03 (i,j)&#8712;P &#8727; in cijx&#8727; ij &#8805; \x03 (i,j)&#8712;P &#8727; in cijx&#8727; ij + \x03 (i,j)&#8712;P &#8727; out cijx&#8727; ij = \x03 (i,j)&#8712;P cijx&#8727; ij. Therefore, we have the following theorem: Theorem 3. Let G = (V, E, c) be an arbitrary instance of CPP such that c is integer-valued. Any 0-1 vector returned by our algorithm (i.e., RP&#8727; (G)+pp) is optimal to P(G). 5 MaxSAT Counterparts Here we present MaxSAT counterparts of both our ILP formulation (i.e., RP(G)) and ILP-based exact algorithm (i.e., RP&#8727; (G)+pp). It should be noted that we here con- sider WCC rather than CPP. As described above, WCC is equivalent to CPP from an exact optimization perspective. Let G = (V, E+, E&#8722;, c) be an instance of WCC. Note that c : E+ &#8746; E&#8722; &#8594; Q&gt;0 is an edge weight function, where Q&gt;0 is the set of positive rational numbers. The (positive) edge weights represent the strength of similarity and dissimilarity for {i, j} &#8712; E+ and {i, j} &#8712; E&#8722;, respectively. For simplic- ity, we denote cij = c({i, j}) for each {i, j} &#8712; E+ &#8746; E&#8722;. We revisit MaxSAT-Transitive introduced by Berg and Ja&#776;rvisalo (2017), which is the MaxSAT counterpart of P(G). Let V = {1, 2, . . . , n} and P = {(i, j) : 1 &#8804; i &lt; j &#8804; n}. For each (i, j) &#8712; P, we introduce a Boolean variable xij equal to True if i, j &#8712; V are in the same cluster and False otherwise. Then MaxSAT-Transitive, which we refer to as S-P(G) in the present study, can be represented as follows: Hard clauses: (&#172;xij &#8744; &#172;xjk &#8744; xik) &#8704;(i, j, k) &#8712; T, (&#172;xij &#8744; xjk &#8744; &#172;xik) &#8704;(i, j, k) &#8712; T, (xij &#8744; &#172;xjk &#8744; &#172;xik) &#8704;(i, j, k) &#8712; T, Soft clauses: (xij) with weight cij &#8704;(i, j) &#8712; P with {i, j} &#8712; E+, (&#172;xij) with weight cij &#8704;(i, j) &#8712; P with {i, j} &#8712; E&#8722;, where T = {(i, j, k) : 1 &#8804; i &lt; j &lt; k &#8804; n}. The set of hard clauses is a clausal representation of the set of triangle inequality constraints in P(G), and the set of soft clauses is a clausal representation of the objective function in P(G). By beginning with S-P(G), we can reproduce our results for ILP in the context of MaxSAT; speci&#64257;cally, we can ob- tain S-RP(G), S-RP(G), and S-RP&#8727; (G)+S-pp, which are the MaxSAT counterparts of RP(G), RP(G), and RP&#8727; (G)+pp, respectively. The detailed description of them is omitted ow- ing to space limitations. We have the following theorems: Theorem 4 (MaxSAT counterpart of Theorem 2). Let G = (V, E+, E&#8722;, c) be an arbitrary instance of WCC such that c is integer-valued. Any optimal solution to S-RP(G) is also optimal to S-P(G). Theorem 5 (MaxSAT counterpart of Theorem 3). Let G = (V, E+, E&#8722;, c) be an arbitrary instance of WCC such that c is integer-valued. Any True-False assignment returned by our algorithm (i.e., S-RP&#8727; (G)+S-pp) is optimal to S-P(G). 6 Experimental Evaluation The purpose of our experiments is to evaluate the effective- ness of our ILP-based approaches and their MaxSAT coun- terparts in terms of both memory ef&#64257;ciency and computation time. To this end, we use well-known real-world datasets aris- ing in the context of correlation clustering, group technology, and community detection. 6.1 ILP-Based Approaches We &#64257;rst compare our ILP formulation (i.e., RP(G)) and ILP- based exact algorithm (i.e., RP&#8727; (G)+pp) with the previous ILP formulations (i.e., P(G) and RP(G)) and the state-of- the-art MaxSAT formulation (i.e., MaxSAT-Binary). As for RP(G), we set the parameter \x03 as follows: \x03 = 1 n2 and 2 n2 , both of which are less than 1/ \x04n 2 \x05 . All ILP formula- tions were solved using Gurobi Optimizer 7.0.2 with default parameters. As for MaxSAT-Binary, we employed the pre- processing and symmetry-breaking operations mentioned in Berg and Ja&#776;rvisalo (2017). The preprocessing was simulated using Coprocessor 3.0 and the symmetry-breaking proce- dure called REMOVESLACK was applied. MaxSAT-Binary was solved using MaxHS 2.9, as recommended in Berg and Ja&#776;rvisalo (2017). 1391 Table 1: Instances used in our experiments. ID Name n m&gt;0/ \x04n 2 \x05 m&#8805;0/ \x04n 2 \x05 P1 Protein1 669 4.22% 98.49% P2 Protein2 587 6.36% 98.21% P3 Protein3 567 6.39% 97.95% P4 Protein4 654 2.64% 98.87% G9 Ch-8x20b 28 24.07% 81.75% G14 Mc-16x24 40 11.47% 61.81% G16 KI-16x43 59 7.36% 67.15% G17 Ca-18x24 42 10.22% 60.05% G18 MT-20x20 40 14.23% 62.95% G19 Ku-20x23 43 12.51% 61.57% G21 Bo-20x35 55 10.03% 62.90% G25 CH5-24x40 64 6.50% 58.88% G26 CH6-24x40 64 6.50% 58.88% G27 CH7-24x40 64 6.50% 58.88% G28 Mc-27x27 54 15.30% 64.36% G29 Ca-28x46 74 7.81% 60.13% G30 Ku-30x41 71 5.15% 55.65% G31 St-30x50-1 80 4.87% 57.41% G32 St-30x50-2 80 5.28% 57.82% G33 Ki-36x90 126 4.23% 66.41% G34 MC-37x53 90 24.39% 75.43% G35 Ch-40x100 140 4.32% 63.21% C1 Wafa-CEO 41 11.10% 63.54% C2 Divorces 59 11.63% 85.33% C3 Hollywood movies 102 3.73% 56.79% C4 Scotland interlocks 244 1.21% 59.00% C5 Graph product 674 0.27% 50.43% C6 Network science 2,549 0.08% 53.11% The time limit was set to 4 hours and the memory limit was set to 96 GB. The experiments were conducted on a Linux machine with Intel Xeon Processor E5-2650 v2 2.60 GHz CPU and 96 GB RAM. Correlation clustering. Correlation clustering instances were &#64257;rst tested. Speci&#64257;cally, we considered MAXAGREE in the edge-weighted setting (i.e., WCC). The upper section of Table 1 lists the instances on which experiments were con- ducted, which were generated from protein sequence datasets on http://www.paccanarolab.org/scps in the same manner as in Berg and Ja&#776;rvisalo (2017). The data consist of similarity values between amino-acid sequences that were computed using BLAST (Altschul et al. 1990). The results are detailed in Table 2. The number of vari- ables is always equal to \x04n 2 \x05 = n(n &#8722; 1)/2. The number of constraints in RP&#8727; (G) is omitted because it is exactly the same as in RP(G). OM in some columns indicates that the memory requirements of the formulation (and the solving phase) exceed the limit (i.e., 96 GB). For the formulations that could be stored on the machine but could not be solved within the time limit, the relative gaps (i.e., (UB &#8722; LB)/LB, where UB and LB, respectively, are the upper and lower bounds on the optimal value) obtained by the time limit are presented within parentheses if they are &#64257;nite; otherwise OT is given. For each instance, the best computation time (or the relative gap) among the formulations is written in bold. It is seen that neither P(G) nor RP(G) could be stored on the machine for instances P1 and P4 owing to a shortage of memory capacity. Although RP(G) had fewer constraints than P(G), the decrement was quite small, with at most 0.1% of the constraints removed. By contrast, our formulations, RP(G) and RP&#8727; (G), had far fewer constraints, with about 90% of the constraints removed. Correspondingly, the mem- ory limit was not exceeded, and optimal solutions were ob- tained for instances P1 and P2. The results also show that our formulations outperformed MaxSAT-Binary. In fact, only RP(G) and RP&#8727; (G)+pp could obtain an optimal solution to instance P2 and nearly-optimal solutions for instances P3 and P4, although MaxSAT-Binary solved instance P1 faster. Group technology. An assessment of group technology instances was then conducted; some of these are listed in the middle section of Table 1. The instances were generated from manufacturing cell formation datasets on http://mauricio.resende.info/data in the manner described in Example 2; a detailed description of the datasets can be found in Gonc&#807;alves and Resende (2004). Although there were originally 35 instances, which were indexed from G1 to G35, some instances are omitted owing to space limi- tations. Our preliminary experiments showed that all formu- lations could solve the omitted instances within 10.0 s. The results are summarized in Table 2. Because the in- stances are smaller than those used in correlation clustering, P(G) and RP(G) could always be stored on the machine. Although RP(G) had fewer constraints than P(G), the com- putation time (or the relative gap) increased in 7 out of 17 instances. Again, our formulations, RP(G) and RP&#8727; (G), pro- duced far fewer constraints. In fact, even for relatively small instances, at least 50% of the constraints were removed, with the &#64257;gure increasing to above 90% for some large instances. Furthermore, the computation time was reduced signi&#64257;cantly. In particular, RP&#8727; (G)+pp could obtain optimal solutions for all instances within the time limit. The results also show that MaxSAT-Binary performed no better than P(G) and RP(G). In fact, for any instance that could not be solved by P(G) and RP(G), MaxSAT-Binary also failed to obtain an optimal solution, and moreover, only MaxSAT-Binary exceeded the memory limit for some instances owing to its signi&#64257;cant memory requirements in the search phase. Community detection. Community detection instances were then tested, with particular consideration given to the bipartite modularity maximization problem. The last section of Table 1 lists the instances on which experiments were conducted, which were generated from network datasets on http://vlado.fmf.uni-lj.si/pub/networks/data in the manner described in Example 3. The results are detailed in Table 2. It is seen that the trend of the results is similar to that produced in the correlation clustering and group technology assessments, i.e., RP(G) and RP&#8727; (G)+pp outperformed P(G), RP(G), and MaxSAT- Binary. Most strikingly, our approaches could obtain an opti- mal solution to instance C6 with 2,549 vertices, while P(G) and RP(G) required more than 8 billion and 6 billion con- straints, respectively. Furthermore, MaxSAT-Binary left a very large relative gap (i.e., 6,350.3%). 1392 Table 2: Results for the previous ILP formulations, our ILP-based approaches, and the state-of-the-art MaxSAT formulation. ID P(G) RP(G) RP(G) \x03 = 1 n2 \x03 = 2 n2 RP&#8727; (G)+pp MaxSAT-Binary #constr. time(s) #constr. time(s) #constr. time(s) time(s) time(s) #var. #clauses time(s) P1 149,038,482 OM 148,995,305 OM 12,106,852 4,010.3 3,505.6 3,796.2 167,184 684,568 2,304.8 P2 100,614,735 OM 100,571,045 OT 12,191,742 2,774.3 3,430.9 3,039.9 179,968 744,956 (48.1%) P3 90,660,465 OT 90,611,160 OT 10,995,760 (0.3%) (0.3%) (0.3%) 173,928 719,876 (18.1%) P4 139,222,212 OM 139,199,019 OM 7,161,805 (0.2%) (0.2%) (0.2%) 109,692 434,570 (119.2%) G14 27,417 20.8 23,366 17.0 5,902 4.2 4.6 4.2 3,412 12,120 12.3 G16 97,527 233.3 84,297 551.1 13,560 14.2 13.9 12.4 6,212 22,440 64.3 G17 34,440 18.4 28,920 14.0 6,640 5.2 4.8 3.2 3,960 14,122 12.5 G18 29,640 804.4 25,661 803.9 7,839 433.6 343.6 273.9 3,680 12,962 OM G19 37,023 66.6 31,606 52.4 8,646 18.9 18.6 14.4 4,196 15,128 219.5 G21 78,705 126.8 67,196 149.2 14,938 21.0 21.2 19.1 6,260 22,856 182.2 G25 124,992 474.5 102,860 245.2 15,750 16.6 12.9 14.7 9,536 31,718 110.4 G26 124,992 426.8 102,875 418.3 15,765 62.2 61.1 25.5 9,536 31,718 (1.4%) G27 124,992 1,338.4 102,887 1,145.3 15,777 227.2 258.1 168.9 9,536 31,718 (160.6%) G28 74,412 2,426.5 65,114 1,419.3 21,044 1,322.7 1,193.3 570.1 6,480 23,758 OM G29 194,472 (6.4%) 161,752 (8.5%) 28,840 1,596.3 1,715.2 1,296.5 12,628 48,267 OM G30 171,465 29.8 137,420 30.7 17,222 4.7 6.2 4.3 12,064 46,280 12.3 G31 246,480 78.4 199,476 85.0 23,508 10.7 12.0 10.6 14,620 55,683 14.9 G32 246,480 2,634.1 200,359 4,556.4 25,405 127.0 107.8 47.0 14,620 55,683 (137.2%) G33 842,520 (151.3%) 716,019 (132.1%) 68,435 (6.0%) (6.7%) 11,963.4 25,980 100,201 OM G34 352,440 (13.2%) 326,247 (82.9%) 146,067 5,968.0 7344.6 4,131.6 18,909 73,342 (149.5%) G35 1,342,740 16.3 1,121,684 13.4 112,904 1.3 1.3 1.3 42,240 168,918 17.8 C1 31,980 54.8 27,466 41.4 6,640 9.4 10.4 7.5 3,612 12,952 14.1 C2 97,527 4,927.8 93,475 4,749.9 20,116 75.6 74.5 64.8 4,308 15,232 138.9 C3 515,100 (11.6%) 413,487 (11.8%) 37,470 8,711.4 10,821.9 (0.4%) 23,190 90,651 OM C4 7,174,332 (8.4%) 5,840,182 (8.4%) 172,070 (1.3%) (1.9%) (1.5%) 129,024 527,718 (141.9%) C5 152,410,272 OM 114,839,168 OM 822,272 15.9 16.2 18.2 1,369,960 5,888,398 4,994.9 C6 8.3G OM 6.3G OM 13,130,379 397.2 407.3 402.4 21,417,336 94,669,067 (6,350.3%) 6.2 MaxSAT Counterparts Next we compare our MaxSAT formulation (i.e., S-RP(G)) and MaxSAT-based exact algorithm (i.e., S-RP&#8727; (G)+S-pp) with the MaxSAT counterparts of P(G) and RP(G) (i.e., S-P(G) and S-RP(G)). As for S-RP(G), we set the parameter \x03 as in its ILP counterpart, i.e., \x03 = 1 n2 and 2 n2 . All MaxSAT formulations were solved using MaxHS 2.9. The results are detailed in Table 3 with the same notations as in Table 2. As for S-RP(G), the left and right columns correspond to the results of \x03 = 1 n2 and \x03 = 2 n2 , respec- tively. Note that the number of hard clauses in each MaxSAT formulation is equal to the number of constraints in its ILP counterpart (see Table 2). It is seen that our results are still effective for MaxSAT. In fact, S-RP(G) could solve 6 out of 11 instances that could be solved neither by S-P(G) nor by S-RP(G), and moreover, S-RP&#8727; (G) could solve instances P1, P2, and P4 much faster than S-P(G) and S-RP(G). </corps>
-> Perfect 


<discussion /> 

-> Perfect 
<conclusion>7 Conclusion In this study, we have investigated the design of mathematical programming formulations and constraint satisfaction formu- lations for CPP. More speci&#64257;cally, we have presented a novel ILP formulation, an ILP-based exact algorithm, and their MaxSAT counterparts. The experimental results demonstrate that our approaches signi&#64257;cantly outperform the state-of-the- art formulations in terms of both memory ef&#64257;ciency and computation time. Table 3: Results for the MaxSAT counterparts. ID S-P(G) S-RP(G) S-RP(G) S-RP&#8727; (G)+S-pp time(s) time(s) time(s) time(s) time(s) P1 4,362.6 5,284.4 (0.5%) (0.7%) 1,058.4 P2 2,690.6 2,779.7 2,049.8 2,366.6 486.0 P3 (11.0%) (3.1%) (253.1%) (8.2%) (3.9%) P4 6,998.2 7,773.0 (31.8%) (31.8%) 3,200.5 G14 14.9 14.5 16.6 18.0 21.8 G16 19.6 20.1 41.4 49.0 39.2 G17 6.1 6.2 11.4 13.1 10.5 G18 (140.0%) (140.0%) 3,782.8 3,868.5 (140.0%) G19 195.7 198.7 45.4 50.8 637.7 G21 124.3 126.6 49.9 60.2 132.4 G25 31.9 43.4 46.2 44.4 32.3 G26 2,017.7 1,986.3 348.5 484.6 4197.1 G27 (121.1%) (121.1%) 1,615.8 2,338.5 (123.7%) G28 OM OM 3,995.1 6,949.2 OM G29 OM OM 8,658.7 11085.3 OM G30 7.1 6.1 15.8 16.8 14.7 G31 8.7 9.3 26.9 28.2 8.9 G32 (118.0%) (118.0%) 772.0 841.4 11,172.4 G33 OM OM OT OT OM G34 (164.4%) (164.4%) OT 13,421.1 (154.9%) G35 14.4 11.4 2.8 2.4 3.1 C1 13.8 13.4 14.5 18.0 9.7 C2 83.5 87.6 119.3 82.9 106.2 C3 (1,340.7%) (1,340.7%) OT OT (802.1%) C4 (65.8%) (65.8%) OT OT (75.3%) C5 4,162.6 2,794.7 525.7 555.7 268.0 C6 OM OM (18.3%) (25.7%) (8.5%) 1393 Acknowledgments The authors would like to thank the anonymous reviewers for their valuable suggestions and helpful comments. The &#64257;rst author is supported by a Grant-in-Aid for Research Activity Start-up (No. 17H07357). This work was supported by JST ERATO Grant Number JPMJER1201, Japan. </conclusion>
-> Perfect


-> Perfect
<biblio>References Agarwal, G., and Kempe, D. 2008. Modularity-maximizing graph communities via mathematical programming. Euro- pean Physical Journal B 66(3):409&#8211;418. Aggarwal, C. C., and Reddy, C. K. 2013. Data Clustering: Algorithms and Applications. CRC Press. Ahn, K. J.; Cormode, G.; Guha, S.; McGregor, A.; and Wirth, A. 2015. Correlation clustering in data streams. In ICML &#8217;15: Proceedings of the 32nd International Conference on Ma- chine Learning, 2237&#8211;2246. Altschul, S. F.; Gish, W.; Miller, W.; Myers, E. W.; and Lipman, D. J. 1990. Basic local alignment search tool. Journal of Molecular Biology 215(3):403&#8211;410. Awasthi, P.; Balcan, M.-F.; and Voevodski, K. 2014. Local al- gorithms for interactive clustering. In ICML &#8217;14: Proceedings of the 31st International Conference on Machine Learning, 550&#8211;558. Bansal, N.; Blum, A.; and Chawla, S. 2004. Correlation clustering. Machine Learning 56(1&#8211;3):89&#8211;113. Barber, M. J. 2007. Modularity and community detection in bipartite networks. Physical Review E 76:066102. Berg, J., and Ja&#776;rvisalo, M. 2017. Cost-optimal constrained correlation clustering via weighted partial maximum satis&#64257;a- bility. Arti&#64257;cial Intelligence 244:110&#8211;142. Bonchi, F.; Gionis, A.; and Ukkonen, A. 2013. Overlapping correlation clustering. Knowledge and Information Systems 35(1):1&#8211;32. Bruckner, S.; Hu&#776;ffner, F.; Komusiewicz, C.; and Niedermeier, R. 2013. Evaluation of ILP-based approaches for partitioning into colorful components. In SEA &#8217;13: Proceedings of the 12th International Symposium on Experimental Algorithms, 176&#8211;187. Chierichetti, F.; Dalvi, N.; and Kumar, R. 2014. Correlation clustering in MapReduce. In KDD &#8217;14: Proceedings of the 20th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 641&#8211;650. Dinh, T. N., and Thai, M. T. 2015. Toward optimal com- munity detection: From trees to general weighted networks. Internet Mathematics 11(3):181&#8211;200. Fortunato, S. 2010. Community detection in graphs. Physics Reports 486(3):75&#8211;174. Gonc&#807;alves, J. F., and Resende, M. G. C. 2004. An evolution- ary algorithm for manufacturing cell formation. Computers &amp; Industrial Engineering 47(2&#8211;3):247&#8211;273. Groover, M. P. 2007. Automation, Production Systems, and Computer-Integrated Manufacturing. Prentice Hall Press. Gro&#776;tschel, M., and Wakabayashi, Y. 1989. A cutting plane algorithm for a clustering problem. Mathematical Program- ming 45(1&#8211;3):59&#8211;96. Jaehn, F., and Pesch, E. 2013. New bounds and constraint propagation techniques for the clique partitioning problem. Discrete Applied Mathematics 161(13&#8211;14):2025&#8211;2037. Jain, A. K.; Murty, M. N.; and Flynn, P. J. 1999. Data clustering: A review. ACM Computing Surveys 31(3):264&#8211; 323. Kim, S.; Yoo, C. D.; Nowozin, S.; and Kohli, P. 2014. Image segmentation using higher-order correlation clustering. IEEE Transactions on Pattern Analysis and Machine Intelligence 36(9):1761&#8211;1774. Miyauchi, A., and Miyamoto, Y. 2013. Computing an up- per bound of modularity. European Physical Journal B 86(7):302. Miyauchi, A., and Sukegawa, N. 2015a. Maximizing Bar- ber&#8217;s bipartite modularity is also hard. Optimization Letters 9(5):897&#8211;913. Miyauchi, A., and Sukegawa, N. 2015b. Redundant con- straints in the standard formulation for the clique partitioning problem. Optimization Letters 9(1):199&#8211;207. Newman, M. E. J., and Girvan, M. 2004. Finding and evaluating community structure in networks. Physical Review E 69:026113. Nowozin, S., and Jegelka, S. 2009. Solution stability in linear programming relaxations: Graph partitioning and un- supervised learning. In ICML &#8217;09: Proceedings of the 26th International Conference on Machine Learning, 769&#8211;776. Oosten, M.; Rutten, J. H. G. C.; and Spieksma, F. C. R. 2001. The clique partitioning problem: Facets and patching facets. Networks 38(4):209&#8211;226. Puleo, G. J., and Milenkovic, O. 2016. Correlation clustering and biclustering with locally bounded errors. In ICML &#8217;16: Proceedings of the 33rd International Conference on Ma- chine Learning. Van Gael, J., and Zhu, X. 2007. Correlation clustering for crosslingual link detection. In IJCAI &#8217;07: Proceedings of the 20th International Joint Conference on Arti&#64257;cial Intelligence, 1744&#8211;1749. Wakabayashi, Y. 1986. Aggregation of Binary Relations: Al- gorithmic and Polyhedral Investigations. Ph.D. Dissertation, Universita&#776;t Augsburg. Xu, R., and Wunsch, D. 2005. Survey of clustering algo- rithms. IEEE Transactions on Neural Networks 16(3):645&#8211; 678. 1394 </biblio>
-> Perfect 

14 Perfect / 16
2 Incorrect / 16

Precision Stricte : 14/16
Precision souple : 14/16

</article>

</opml>'
